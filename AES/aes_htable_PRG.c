#include <stdio.h>

#include "aes.h"
#include "aes_htable_prg.h"
#include "../Util/prg3.h"
#include "../Util/share.h"

#define TSIZE 256 //16 for PRESENT


byte x_shares[160*(shares_N-1)]; //Shares of x used as part of pre-processing.  496 *(N2-1) fpr PRESENT
byte T[160*TSIZE]; //Size of pre-computed tables for 10*16=160 S-box calls for AES-128, 496*TSIZE for PRESENT.


//************Functions for Normal variant using robust PRG *******************


//*************off-line functions******

void loc_refresh_table_r(byte *Tp,byte a,int n,int ind,int count) //LR for lookup table using robust PRG for normal share
{
    unsigned int pre_val=count*(n-1)*(n-1)*TSIZE;


    for(int k=0;k<TSIZE;k++)
    {
		for(int i=1;i<n;i++)
		{
            unsigned int val=pre_val+(ind*(n-1)*TSIZE)+(k*(n-1))+(i-1); //randoms needed per shift + per column + per row
            byte tmp=get_robprg3(n,val);
            set_robprgcount3();
            Tp[k]=Tp[k] ^ tmp;
     	}


        if(ind>0) //recomputation
        {
            for(int i=1;i<n;i++)
            {
                int previous_val=pre_val+((ind-1)*(n-1)*TSIZE)+((k^a)*(n-1))+(i-1);
                byte tmp=get_robprg3(n,previous_val);
                Tp[k]=Tp[k] ^ tmp;
            }
        }

    }
}



void loc_refresh_table_r_inc(byte *Tp,byte a,int n,int ind,int count) //LR for lookup table using robust PRG for increasing shares.
{
    unsigned int pre_val=count*n*(n-1)*TSIZE/2;

    for(int k=0;k<TSIZE;k++)
    {
		for(int i=0;i<=ind;i++)
		{
		    int t= ind * (ind+1)/2;
            int val=pre_val+(t*TSIZE)+(k*(ind+1))+(i); //randoms needed per shift + per column + per row
            byte tmp=get_robprg3(n,val);
			set_robprgcount3();
			Tp[k]=Tp[k] ^ tmp;
     	}

        if(ind>0)
        {
            for(int i=0;i<ind;i++)
            {
                int t= (ind-1) * ind/2;
                int previous_val=pre_val+(t*TSIZE)+((k^a)*(ind))+(i);
                byte tmp=get_robprg3(n,previous_val);
                Tp[k]=Tp[k] ^ tmp;
            }
        }

    }
}


void shift_tab(byte a,byte *Tp,int count)//Shift the entries of lookup table (LUT) by x_i
{
	unsigned int j,temp,temp1;

	for(j=0;j<TSIZE;j++)
	{
		temp=count*TSIZE;
		temp1=j^a;
    Tp[j]=T[temp+temp1];
	}
}


void htable_r(int n,int count,int choice)//choice= 1 for normal 0 for increasing. LUT using robust PRG
{
  byte Tp[TSIZE];
  int i,k;

  for(k=0;k<TSIZE;k++)
     T[count*TSIZE+(k)]=sbox[k];

  for(i=0;i<(n-1);i++) // In pre-proessing, T will be shifted by n-1 shares.
  {
    shift_tab(x_shares[count*(shares_N-1)+i],Tp,count);

    if(choice==NPRG)
        loc_refresh_table_r(Tp,x_shares[count*(shares_N-1)+i],n,i,count);

    else if(choice==IPRG)
        loc_refresh_table_r_inc(Tp,x_shares[count*(shares_N-1)+i],n,i,count);


    for(k=0;k <TSIZE;k++)
      T[count*TSIZE+(k)]=Tp[k];

  }
}


//********************* Pre-processing of Table T ***************************


//*********online functions*********



//**************Normal variant htable**********

void read_htable_r(byte a,byte *b,int n,int count) //Online function to read T(x_n), robust PRG
{
  int pre_val=count*(n-1)*(n-1)*TSIZE;
  int val=pre_val+((n-2)*(n-1)*TSIZE)+((n-1)*a);

	b[0]=T[count*TSIZE+(a)];

    for(int j=1;j<n;j++)
        b[j]=get_robprg3(n,val+(j-1)); //recomputation of output masks of T(x_n)

    locality_refresh(b,n);
}


void subbyte_htable_r(byte *a,int n,int count)
{
    read_htable_r(a[n-1],a,n,count);
}

//**************Online: Increasing shares*************

void read_htable_inc_r(byte a,byte *b,int n,int count) // Read T(x_n) for increasing shares of robust PRG
{
    unsigned int pre_val=count*n*(n-1)*TSIZE/2;
    unsigned int t= ((n-2) *(n-1)*TSIZE)/2;
    unsigned int val=pre_val+t+(a*(n-1)); //randoms needed per shift + per column + per row

	b[0]=T[count*TSIZE+(a)];

   for(int j=0;j<=n-2;j++)
    b[j+1]=get_robprg3(n,val+j); //recomputation of n-1 masks of T(x_n)

  locality_refresh(b,n);
}


void subbyte_htable_r_inc(byte *a,int n,int count)
{
    read_htable_inc_r(a[n-1],a,n,count);
}

//************End of functions for robust PRG*******************


//**********************htable using multiple PRG**************


//************Functions for Normal variant using multi PRG*******************

void loc_refresh_table_m(byte *Tp,byte a,int n,int ind,int count) //LR for lookup table using randomness generated by multiple PRG
{
    unsigned int pre_val= count*TSIZE;
	int i,j,t;

    for(j=0;j<TSIZE;j++)
    {
		for(i=1;i<n;i++)
		{
			unsigned int val=ind*(n-1);

            if((pre_val+j)%2) //The polynomial evaluation runs for even values of count
               set_mprg_lr_count();

            byte tmp=get_mprg_lr(val+(i-1),n,pre_val+j);
            Tp[j]=Tp[j] ^ tmp;
     	}

        if(ind>0) //recomputation of n-1 columns from previous shift
        {
            for(i=1;i<n;i++)
            {
                unsigned int val=(ind-1)*(n-1);
                t=(j^a);
                byte tmp=get_mprg_lr(val+(i-1),n,pre_val+t);
                Tp[j]=Tp[j] ^ tmp;
            }
        }

    }
}



//************Functions for Increasing shares variant using multi PRG*******************

void loc_refresh_table_inc_m(byte *Tp,byte a,int n,int ind,int count)
{
	unsigned int pre_val= count*TSIZE;
    for(int k=0;k<TSIZE;k++)
    {
        for(int i=0;i<=ind;i++)
        {
            int val=(ind*(ind+1))/2;

            if((pre_val+k)%2) //The polynomial evaluation runs for even values of count
                set_mprg_lr_count();

            byte tmp=get_mprg_lr(val+i,n,pre_val+k);
            Tp[k]=Tp[k] ^ tmp;
        }

        if(ind>0)
        {
            for(int i=0;i<ind;i++)
            {
                int val=((ind-1)*ind)/2;
                byte tmp=get_mprg_lr(val+i,n,pre_val+(k^a));
                Tp[k]=Tp[k] ^ tmp;
            }
        }

    }
}


//**************LUT pre-processing using multiple PRG**********

void htable_m(int n,int count,int choice)//Choice 1 for normal PRG 0 for Increasing shares
{
    unsigned int j,i,t,temp;
    byte Tp[TSIZE];
    for(j=0;j<TSIZE;j++)
	{
		temp=count*TSIZE;
		T[temp+j]=sbox[j];
	}


    for(i=0;i<(shares_N-1);i++) // In pre-proessing, T will be shifted by n-1 shares.
    {

        t=count*(shares_N-1);
        temp=x_shares[t+i];

        shift_tab(temp,Tp,count);

        if(choice==NPRG)
            loc_refresh_table_m(Tp,temp,n,i,count);

        else if(choice==IPRG)
            loc_refresh_table_inc_m(Tp,temp,n,i,count);


		for(j=0;j<TSIZE;j++)
		{
            temp=count*TSIZE;
            T[temp+j]=Tp[j];
		}
  }
}

/******************Online functions: multiple PRG **********/

void read_htable_m(byte a,byte *b,int n,int count) //Normal variant
{
	unsigned int pre_val=count*TSIZE;
	unsigned int val=(n-2)*(n-1);
	b[0]=T[(count*TSIZE)+a];

	for(int j=1;j<n;j++)
		b[j]=get_mprg_lr(val+j-1,n,pre_val+a); //recomputation of n-1 output masks of T(x_n)

	locality_refresh(b,n);
}

void read_htable_inc_m(byte a,byte *b,int n,int count) //Increasing shares
{
    unsigned int pre_val=count*TSIZE;
    unsigned int val=((n-2)*(n-1))/2;

	b[0]=T[(count*TSIZE)+a];

    for(int j=1;j<n;j++)
			b[j]=get_mprg_lr(val+j-1,n,pre_val+a); //recomputation of n-1 output masks of T(x_n)

		locality_refresh(b,n);
}

void subbyte_htable_mprg(byte *a,int n,int count)
{
    read_htable_m(a[n-1],a,n,count);
}

void subbyte_htable_inc_mprg(byte *a,int n,int count)
{
    read_htable_inc_m(a[n-1],a,n,count);
}

//************End of functions for Increasing shares multi PRG*******************

/***************Pre-processing of 160 tables for AES**********/

void gen_t_forall(int n,int choice,int type) //Check for robust/multiple PRG
{
    unsigned int temp;
    byte a[shares_N-1];

   	for(int i=0;i<160;i++)
    {
		gen_rand(a,n-1);
		temp=i*(n-1);

        for(int j=0;j<(n-1);j++)
        {
            x_shares[temp+j]=a[j];

        }

        //printf("calling htable\n");
		if(type==MPRG)
           htable_m(n,i,choice);
		else if(type==RPRG)
           htable_r(n,i,choice);

    }

}


//************state shares*************


void subbytestate_share_prg(byte stateshare[16][shares_N],int n,void (*subbyte_share_call)(byte *,int,int),int round)
{
  unsigned int t,ind;

  for(int i=0;i<16;i++)
  {
	ind=16*round+i;
	t=ind*(shares_N-1);
    byte temp=0;

    for(int j=0;j<n-1;j++)
       temp=temp ^ stateshare[i][j] ^ x_shares[t+j];

    stateshare[i][n-1]=stateshare[i][n-1] ^ temp;
    subbyte_share_call(stateshare[i],n,ind);

  }

}
